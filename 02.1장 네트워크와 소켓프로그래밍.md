# 1장. 네트워크와 소켓 프로그래밍

* 호스트 : 최종 사용자의 응용 프로그램을 수행하는 주체
* 라우터 : 인터넷 모뎀, 허브 등
-> 호스트에서 생성된 데이터를 여러 네트워크를 거쳐 전송함으로써 서로 다른 네트워크에 속한 호스트 간에 데이터를 교환할 수 있게 하는 장비
* 통신 프로토콜 (인터넷망 포괄)
-> 호스트와 라우터, 라우터와 라우터, 호스트와 호스트가 통신하기 위한 정해진 절차와 방법

* TCP/IP 프로토콜 : 가장 대표적인 통신 프로토콜
- 인터넷의 핵심 프로토콜인 TCP와 IP를 비롯한 각종 프로토콜
- **운영체제의 일부로 구현**(윈속 라이브러리?프로그램?)되며,   
- **응용 프로그램은 운영체제가 제공하는 TCP/IP 프로토콜의 서비스를 사용해 통신**
- 하나의 호스트안에는 크게 네가지 형태로 나열된다.
1. 응용계층 : **TELNET**,FTP,HTTP,SMTP,MIME,SNMP,... (호스트에서 운영할 수 있는 프로그램이름)
2. 전송계층 : TCP,UDP : 데이터를 보내는 방식
3. 인터넷계층 : IP(고유적인 인터넷 주소, IP adress)
4. 네트워크 접근 계층 : 랜카드(장치드라이버,메인보드의 기본적으로 장착), 네트워크 하드웨어

* 네트워크 접근 계층
1. 역할
- 물리적 네트워크를 통한 데이터 송수신
2. 구성 요소
- 네트워크 하드웨어 + 장치 드라이버
3. 주소 지정 방식
- 물리 주소 ex) 이더넷:48비트 물리 주소
![image](https://user-images.githubusercontent.com/76835313/133450809-360d6c5f-6054-42d0-ac63-7d78b32c0748.png)
![image](https://user-images.githubusercontent.com/76835313/133450842-5f6d584b-d570-47be-89f3-0b59c41508ff.png)
- 전세계적으로 랜카드 자체는 절대로 동일한 주소를 가질 수 없다.

* 인터넷 계층
1. 역할
- 네트워크 접근 계층의 도움을 받아 데이터를 목적지 호스트까지 전달
2. 구성 요소
- **IP 주소** + **라우팅**(or라우터)
3. 주소 지정 방식
-**IP 주소**
 - 소프트웨어적으로 정의된 논리 주소
 - 전 세계적인 유일성과 하드웨어 독립성을 가짐
4. **라우팅** : 인터넷 회선, 단말기
- 데이터를 목적지까지 전달하는 일련의 작업
 - 라우팅에 필요한 정보 수집
 - 라우팅 정보를 기초로 데이터 전달

* 전송 계층
1. 역할
- **최종 통신 목적지(응용 프로그램)를 지정하고, 오류 없이 데이터를 전송**
- **그러나 통신의 최종 목적지는 호스트가 아닌 해당 호스트에서 실행하고 있는 프로세스(응용 프로그램)다.**
- 따라서 전송계층에서 프로세스를 지정하는 일종의 주소를 사용하는데, 이를 포트 번호(port number)라 부른다. 
 - **데이터 손실 또는 손상을 검출해 잘못된 데이터가 목적지에 전달되는 일을 방지하는 역할**을 하는 것이 전송계층이다.
2. 주소 지정 방식
- 포트 번호
3. 대표 프로토콜
- TCP
1. 연결형(connection-oriented) 프로토콜 : 연결 설정 후 통신가능
2. 신뢰성 있는 데이터 전송 : 데이터를 재전송함
3. 일대일 통신(unicast)
4. 데이터 경계 구분 안함 : 바이트 스트림(byte-stream) 서비스
- UDP
1. 비연결형(connectionless) 프로토콜 : 연결 설정 없이 통신 가능
2. 신뢰성 없는 데이터 전송 : 데이터를 재전송하지 않음
3. 일대일 통신(unicast), 일대다 통신(broadcast,multicast)
4. 데이터 경계 구분함 : 데이터그램(datagram) 서비스

* 응용 계층
1. 역할
- 전송 계층을 기반으로 한 **다수의 프로토콜**과 이 프로토콜을 사용하는 응용 프로그램을 포괄 (여기서 사용하는 소켓을 사용한 네트워크 프로그램도 여기에 속한다.)
2. 대표 프로토콜
- Telenet, FTP, HTTP, SMTP, ...

* 패킷 (고유정보+데이터)
1. 각 프로토콜에서 정의한 제어 정보(IP 주소(인터넷 계층에서 관리), 포트 번호(전송계층에서 관리), 오류 체크 코드 등) + 데이터
2. 제어 정보의 위치에 따라 앞쪽에 붙는 **헤더(header)**와 뒤쪽에 붙는 **트레일러(trailer)**로 구분 -> 이를 패킷(packet)이라고 한다.
3. 따라서 패킷은 제어정보 + 데이터 라고 정의할 수 있다. 
![image](https://user-images.githubusercontent.com/76835313/133452581-86f3f469-3a0a-4ab2-a462-d4e7a9551e16.png)
* TCP 헤더가 포트번호
* 이더넷 헤더 : 랜카드의 물리적 주소
* 따라서 각각의 헤더 정보를 가지고 데이터를 함께 보낸다. 

* 패킷 전송 형태
1. 계층별 : 각 계층은 동일 위치의 상대 계층과 통신하는 것으로 간주
![image](https://user-images.githubusercontent.com/76835313/133452854-bf636168-03da-40a3-93bb-d1dc32b4f34b.png)

2. 인터넷 
- 응용 계층, 전송 계층 : 하부 계층이 제공하는 가상적인 연결을 사용해 동작
- 인터넷 계층 : IP 주소와 라우팅 기능을 이용해 패킷 전송 경로 결정
- 네트워크 접근 계층 : 물리 주소를 사용해 실제 패킷 전송
![image](https://user-images.githubusercontent.com/76835313/133453028-bf118bbc-a149-47a3-9f9f-55e03583ce60.png)

* IP 주소
1. 인터넷에 있는 호스트와 라우터의 식별자 : 폐쇄된 네트워크거나 IP를 공유하는 경우가 아니면 전 세계적으로 값이 유일
2. IPv4는 32비트, IPv6는 128비트 사용
3. IPv4는 8비트 단위로 .(dot)로 구분하여 10진수 4개로 표기 ex)147.46.114.70
4. IPv6는 16비트 단위로 :(colon)으로 구분하여 16진수 8개로 표기 ex)2001:0230:abcd:ffab:0023:eb00:ffff:1111

* 포트 번호 (전송 계층에서 관리)
1. 인터넷 통신의 종착점(하나 혹은 여러 프로세스)을 나타내는 식별자
2. TCP와 UDP는 포트 번호로 부호 없는 16비트 정소를 사용하므로 0~65535 범위가 가능
3. 영역별 포트 번호
![image](https://user-images.githubusercontent.com/76835313/133454040-fcd714cb-e7f7-494c-8ae8-9025238aed7a.png)  


* 9000번대~8000번대인 등록된 포트로 실습할 것이다.

* IP 주소와 포트 번호 (프로세스는 운영계층에서 담당한다.)
![image](https://user-images.githubusercontent.com/76835313/133454191-a517ddf2-3c1d-4087-8d2f-cb349a6169c9.png)

* 도메인 이름(IP주소를 다 외울 수 없으니 쉬운이름으로 한다.)
1. IP 주소에 대한 (기억하기 쉬운) 별명
2. 실제 통신할 때는 IP 주소로 변환해야 함

* 클라이언트-서버(client/server) 모델 : 만들어지는 전체적인 네트워크 망 : 호스트와 호스트 관계(내 컴퓨터가 호스트일수도 클라이언트일 수 있다.)
1. 두 프로그램이 상호 작용하는 방식을 나타내는 용어
2. **서비스를 요청하는 쪽은 클라이언트(client), 클라이언트가 요청하는 서비스를 처리하는 쪽은 서버(server)**
![image](https://user-images.githubusercontent.com/76835313/133454505-7e7c1690-15b5-49f6-b4be-dfd4bf6699f7.png)

![image](https://user-images.githubusercontent.com/76835313/133454747-60d23d0f-8c41-4251-b9bd-d1f0b16623df.png)

# 소켓의 개념
* 소켓은 파일 디스크립터(file descriptor) 혹은 핸들(handle)과 유사한 개념으로, 일단 만들고나면 함수를 호출하여 손쉡게 네트워크 통신을 수행할 수 있다. 
* 세 가지 관점
1. 데이터 타입
- 파일 디스크립터 혹은 핸들과 유사한 개념
- 생성과 설정 과정이 끝나면 운영체제의 통신 관련 정보를 참조해 다양한 작업을 편리하게 할 수 있는 데이터 타입
- 응용프로그램이 통신하려면 다음과 같은 요소가 결정되어야 한다.
1) 사용할 프로토콜(TCP/IP, UDP/IP 등()
2) 송신 측 IP 주소
3) 송신 측 포트 번호
4) 수신 측 IP 주소
5) 수신 츨 포트 번호

2. 통신 종단점
- 응용 프로그램은 자신의 소켓이 상대편의 소켓과 연결된것으로 생각하고 데이터를 주고받는다.
![image](https://user-images.githubusercontent.com/76835313/133455138-a0bfd8e4-5dc1-4b12-9d94-1206992fb009.png)
3. 네트워크 프로그래밍 인터페이스
- 통신 양단이 모두 소켓을 사용할 필요는 없다.
- TCP/IP 프로토콜에서 (일반적으로) 응용 계층과 전송 계층 사이에 위치하는 것으로 간주
![image](https://user-images.githubusercontent.com/76835313/133455330-ed800d15-9063-4260-a795-d963f5376842.png)
-> 소켓 인터페이스를 통해서 프로그래밍이 진행된다.

* 윈도우 소켓(윈속 이라는 라이브러리 사용할 것)
1. 버클리 유닉스에서 개발한 네트워크 프로그래밍 인터페이스를 윈도우 환경에서 사용할 수 있게 만든 것
2. 윈도우 95 버전 부터 API에 정식으로 포함하여 제공

* 윈도우 소켓과 유닉스 소켓의 차이점
1. 윈도우 소켓은 DLL을 통해 대부분의 기능이 제공되므로 DLL 초기화와 종료 작업을 위한 함수가 필요하다.
2. 윈도우 프로그램은 대게 GUI를 갖추고 메시지 구동 방식으로 동작하므로 이를 위한 확장 함수가 존재한다.
3. 윈도우는 운영체제 차원에서 멀티스레드를 지원하므로 멀티스레드 환경에서 안정적으로 동작하는 구조와 이를 위한 함수가 필요하다.

* 윈속의 장점
1. 유닉스 소켓과 소스 코드 수준에서 호환성이 높으므로 기존 코드를 이식하여 활용하기 쉽다.
2. 가장 널리 사용하는 네트워크 프로그래밍 인터페이스이므로 한번 배우면 여러 운영체제(윈도우, 리눅스 등)에서 사용 가능하다.
3. TCP/IP 외의 프로토콜도 지원하므로 최소 코드 수정으로 응용 프로그램이 사용할 프로토콜 변경이 가능하다.
4. 비교적 저수준 프로그래밍 인터페이스이므로 세부 제어가 가능하며 고성능 네트워크 프로그램 개발이 가능하다.

* 윈속의 단점
1. 응용 프로그램 수준의 프로토콜을 프로그래머가 직접 설계해야 한다 : 주고받는 데이터 형식이나 전송 절차 등을 고려해 프로그래밍해야 하며, 설계 변경 시에는 코드 수정이 불가피하다.
2. 서로 다른 바이트 정렬 방식을 사용하거나 데이터 처리 단위가 서로 다른 호스트끼리 통신할 경우, 응용 프로그램 수준에서 데이터 변환을 처리해야 한다.

* 윈속 구조
![image](https://user-images.githubusercontent.com/76835313/133456595-71d7d19d-7080-46b9-be75-7b79d1efc2db.png)
- IrDA는 적외선 통신임
# [winsock2 라이브러리](https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-start-page-2)

# SUMMARY
1. 인터넷 통신 개체
- 호스트와 라우터 두 종류가 있다.

2. TCP/IP 프로토콜 구조
- 네트워크 접근 계층 : 물리적 네트워크를 통한 실제 데이터 송수신 담당. 물리 주소 사용
- 인터넷 계층 : 네트워크 접근 계층의 도움을 받아 데이터를 목적지 호스트까지 전달(라우팅), IP 주소 사용
- 전송 계층 : 최종 통신 목적지를 지정하고 오류 없이 데이터를 전송. 포트 번호 사용
- 응용 계층 : 전송 게층을 기반으로 한 다수의 프로토콜과 응용 프로그램을 포괄

3. TCP와 UDP
TCP : 연결형 프로토콜, 신뢰성 있는 데이터 전송, 일대일 통신, 데이터 경계 구분 안함
UDP : 비연결형 프로토콜, 신뢰성 없는 데이터 전송, 일대일, 일대다 통신, 데이터 경계 구분함

4. IP 주소
인터넷에 존재하는 호스트르 ㄹ유일하게 식별. 32비트(IPv4) 또는 128비트(IPv6) 주소를 사용한다.

5. 포트 번호
통신의 종착점(하나 혹은 여러 프로세스)을 식별. 부호 없는 16비트 정수 사용

6. 루프백 주소
- 시스템 자신을 나타내는 의미로 내부적으로만 사용
- IPv4에서는 127.0.0.1로, IPv6에서는 0:0:0:0:0:0:0:1로 정의됨

7. 클라이언트- 서버 모델
- 서비스를 요청하는 쪽은 클라이언트, 서비스를 처리하는 쪽은 서버라 부른다.

8. 소켓의 개념
- 데이터 타입
- 통신 종단점
- 네트워크 프로그래밍 인터페이스

9. 윈속 응용 프로그램
- 대부분의 기능은 WS2_32.DLL로 제공한다. 응용 프로그램 링크 시 WS2_32.LIB 필요하다. 

# 연습문제
1. 이더넷의 48비트 물리 주소의 비트 단위 구조를 조사하고, 자신의 pc에서 사용 중인 이더넷 주소를 분석하시오.
18-03-77-DE-1C-55 16진수 6개니까 2bit* 4* 6=48bit

2. OSI(Open Systems Interconnection) 7계층 모델에 관해 조사하고, 각 계층 기능을 TCP/IP 프로토콜 관점에서 서술하시오.

3. 다음 TCP/IP와 연관된 대표적인 네트워크 연결 장치다. 각각의 기능을 조사하시오.


# 2장
 1. 윈속 초기화
 2. 소켓 생성
 3. 오류 처리

* 윈속 응용 프로그램의 공통 구조
1. 윈속 초기화 : 내가 사용하고 있는 윈도우가 버전이 동일한가?
2. 소켓 생성
3. 네트워크 통신
4. 소켓닫기
5. 윈속 종료

* 윈속 초기화 함수
 
int WSAStartup(
  WORD wVersionRequested,
  LPWSADATAlpWSAData
  );
  
  윈도우 윈속의 마지막 버전은 2.2이다. 3.2버전이런건 없다. 우리가 사용하는 버전은 1.1또는 2.2 두가지 이다. 버전 정도의 매게변수값을 넣어준다.
  * IpWSAData : 윈도우 운영체제가 제공하는 윈속 구현에 관한 정보를 얻을 수 있다.(거의 사용 안함)

* 윈속 종료
- **int WSACleanup(void)**
성공시 : 0, 실패시:SOCKET_ERROR

* 윈속을 초기화하고 초기화된 버전이 맞으면 자동으로 팝업창이 나오면서 윈속이 종료된다. 

         #pragma comment(lib, "ws2_32")
         #include <winsock2.h>

         int main(int argc, char *argv[])
         {
          //윈속 초기화
          WSADATA wsa;
          if(WSAStartup(MAKEWORD(2,2),&wsa)!=0)
           return 1;
          MessageBox(NULL,"윈속 초기화 성공 !!","알림",MB_OK);
          //메세지와 상단의 알림 부분이며 MB_OK는 확인버튼을 의미한다.

          //socket() -> 소켓을 오픈한다.
          SOCKET tcp_sock = socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM는 실질적 소켓타입을 말한다. TCP냐 UDP냐를 말한다.

          //if(tcp_sock==INVALID_SOCKET) err_quit("socket()");
          MessageBox(NULL,"TCP 소켓 생성 성공", "알림",MB_OK);

          //윈속 종료
          closesocket(tcp_sock);

          //윈속 종료
          WSACleanup();
          return 0; 
         }

* #define AF_INET 2 : Internetwork : UDP, TCP, etc. -> IP주소를 할당할건지 udp, tcp로 할건지 결정한다.
* define AF_INET6 23 : Internetwork Version 6 -> IPv6를 의미한다.
* define AF_IRDA 26 : IrDA -> 적외선통신
* define AF_BTH 32 : Bluetooth RFCOMM/L2CAP protocols -> 블루투스 

* TCP -> 소켓타입 : SOCK_STREAM
* UDP -> 소켓타입 : SOCK_DGRAM
- 그냥 파라미터값을 0으로 설정하면 된다. 

SOCKEt socket(
int af,
int type,
int protocol
);

int closesocket(
   SOCKET s
)

* FormatMessage() 함수
DWORD FormatMessage(
DWORD dwFlaags, //옵션
LPCVOID IpSource, //NULL
DWORD dwMessageID, //오류 코드
DWORD dwLanguagedId, //언어
LPTSTR IpBuffer, //오류 문자열 시작 주소
DWORD nSize, //0
va_list* Arguments //NULL
};


# err_quit() 함수
void err_quit(char * msg)
{
LPVOID lpMsgBufl
Formatmessage(
FORMAT_MESSAGE_ALLOCATE_BUFFER
| FORMAT_MESSAGE_FROM_SYSTEM,
NULL,WSAGetLastError(),
MAKELAANGID(LANG_NEUTRAL,SUBLANG_DEFAUlT),
(LPTSTR)&lpMsgBuf,0,NULL);
MessageBox(NULL,(LPCTSTR)lpMsgBuf,msg,MB_ICONERROR);
LocalFree(lpMsgBuf);
exit(1);
}

## 함수 사용 예시
if(socket(...)==INVALID_SOCKET) err_quit("socket()");
if(bind(...)==SOCKET_ERROR) err_quit("bind()");

![image](https://user-images.githubusercontent.com/76835313/134886471-9b5bc903-b1d1-44ec-a16d-4d93003dff3f.png)


## err_display() 함수 정의
void err_display(char * msg)
{
LPVOID lpMsgBufl
Formatmessage(
FORMAT_MESSAGE_ALLOCATE_BUFFER
| FORMAT_MESSAGE_FROM_SYSTEM,
NULL,WSAGetLastError(),
MAKELAANGID(LANG_NEUTRAL,SUBLANG_DEFAUlT),
(LPTSTR)&lpMsgBuf,0,NULL);
printf("[%s]%s",msg,(char*)lpMsgBuf);
LocalFree(lpMsgBuf);
exit(1);
}

1. 윈속 초기화
2. 소켓 생성하고 종료하기
3. 오류메세지 띄우기

# 소켓 생성하기
- af : 주소 체계를 지정한다.
- type : 소켓 타입을 지정한다.
- protocol : 사용할 프로토콜을 지정한다. 

1. 루프백 주소
- 네트워크 프로그래밍 할 때 유용한 IP 주소로 루프백 주소(loopback address)가 있다. 
- IPv4에서는 127.0.0.1, IPv6에서는 0:0:0:0:0:0:0:1 (줄여서 ::1로 표기)로 정의되어있다.
- 루프백 주소는 인터넷에 있는 호스트나 라우터의 고유 주소로는 할당되지 않으며, 시스템 자신을 나타내는 의미로 내부적으로만 사용된다. 예를 들어, 다음 그림과 같이 ping 프로그램을 사용해 루프백 주소로 데이터를 보내면, ping을 실행하고 있는 컴퓨터 자신이 응답하며 외부로는 데이터가 나가지 않는다. 루프백 주소는 한 컴퓨터에서 네트워크 프로그램을 작성하고 테스트 할 때 매우 유용하여 책에서도 자주 사용한다.  

2. TCP 프로토콜 구조
- 응용 계층 : Telnet, FTP, HTTP, SMTP, MIME, SNMP, ...
- TCP, UDP
- IP
- 장치 드라이버 네트워크 하드웨어

3. 윈속 1.x 버전은 유닉스 소켓과 호환성을 제공하면서 TCP/IP 프로토콜을 지원하는 것을 목표로 설계되었다. 그러나 2.x 버전부터는 다양한 프로토콜을 지원하도록 구조를 변경하고 함수를 추가했다. 윈속에서 지원하는 통신 프로토콜은 다음과 같다. 현재 지원하지 않는 프로토콜은 목록에서 제외했다.
- TCP/IP(윈도우 95이상, 윈도우 CE 2.1 이상)
- IPv6(윈도우 XP SP1 이상, 윈도우 CE .NET 4.1 이상)
- IrDA(윈도우 98 이상, 모든 윈도우 CE 버전)
- Bluetooth(윈도우 XP SP2 이상, 윈도우 CE .NET 4.0 이상)
윈속을 사용하면 다음과 같은 장점이 있다.
1. 유닉스 소켓과 소스 코드 수준에서 호환성이 높으므로 기존 코드를 이식하여 활용하기 쉽다.
2. 가장 널리 사용하는 네트워크 프로그래밍 인터페이스 이므로 한번 배우면 여러 운영체제(윈도우, 리눅스 등)에서 사용할 수 있다.
3. TCP/IP 외의 프로토콜도 지원하므로 최소 코드 수정으로 응용프로그램이 사용할 프로토콜을 변결할 수 있다.
4. 비교적 저수준(low-level 혹은 mid-level) 프로그래밍 인터페이스이므로, 세부 제어가 가능하며 고성능 네트워크 프로그램을 개발할 수 있다.

그러나 다음과 같은 단점이 있다.
1. 응용 프로그램 수준의 프로토콜을 프로그래머가 직접 설계해야 한다. 즉, 주고받는 데이터 형식이나 전송 절차 등을 고려해 프로그래밍해야 하며, 설계 변경 시에는 코드 수정이 불가피하다.
2. 서로 다른 바이트 정렬(byte ordering) 방식을 사용하거나 데이터 처리 단위(32비트, 64비트 등) 가 서로 다른 호스트끼리 통신할 경우, 응용 프로그램 수준에서 데이터 변환을 처리해야한다.

4. 소켓 생성하기
- 소켓을 사용해 통신하기 위한 기본 요건은 통신 양단이 같은 프로토콜을 사용하느 ㄴ것이다. 예를 들면, TCP를 사용할 것인지 혹은 UDP를 사용할 것인지를 약속해야 한다.

- socket() 함수는 사용자가 요청한 프로토콜을 사용해 통신할 수 있도록 내부적으로 리소스를 할당하고, 이에 접근할 수 있는 일종의 핸들 값(SOCKET 타입, 32비트 정수)을 리턴한다. 이 값을 소켓 디스크립터(socket descriptor)라 부르며, 각종 소켓 함수를 호출할 때 인자로 전달해 사용한다. 

SOCKET socket(
int af,  
int type,  
int protocol  
);
af : 주소 체계를 지정한다.
type : 소켓 타입을 지정한다.
protocol : 사용할 프로토콜을 지정한다.


5. TCP와 UDP 프로토콜을 사용을 위한 설정
- TCP : AF_INET 또는 AF_INET6 , SOCK_STREAM, 0
- UDP : AF_INET 또는 AF_INET6, SOCK_DGRAM, 0
* 소켓 타입 : 소켓타입은 사용할 프로토콜의 특성을 나타내는 값이다. 자주 사용하는 소켓 타입을 요약하면 아래와같다.
- SOCK_STREAM : 신뢰성 있는 데이터 전송 기능 제공, 연결형 프로토콜
- SOCK_DGRAM : 신뢰성 없는 전송 기능 제공, 비연결성 프로토콜

6. TCP/IP 프로토콜을 사용한 통신




















